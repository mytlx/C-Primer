# Chapter 4. Expressions

## Exercise 4.1
> 表达式`5+10*20/2`的求值结果是多少？  

105


## Exercise 4.2
> 根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。  
> ```cpp
> (a) *vec.begin()  //=>  *(vec.begin())     
> (b) *vec.begin() + 1  //=> (*(vec.begin())) + 1
> ```


## Exercise 4.3
> C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。
> 这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。

C++的效率确实是优势，但是这样的设计很容易出现很多bug，所以如果不是特别熟悉，不要轻易使用那些容易引起歧义的语句吧

## Exercise 4.4
> 在下面的表达式中添加括号，说明其求值的过程及最终结果。编写程序编译该（不加括号的）表达式并输出其结果验证之前的推断。  
> ```cpp
> 12 / 3 * 4 + 5 * 15 + 24 % 4 / 2   
> // => ((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2)
> ```

91


## Exercise 4.5
> 写出下列表达式的求值结果。
> ```cpp
> (a) -30 * 3 + 21 / 5  // => (-30 * 3) + (21 / 5) == -86
> (b) -30 + 3 * 21 / 5  // => -30 + ((3 * 21) / 5) == -18
> (c) 30 / 3 * 21 % 5  // => ((30 / 3) * 21) % 5 == 0
> (d) -30 / 3 * 21 % 4  // => ((-30 /3) * 21) % 4 == -2
> ```


## Exercise 4.6
> 写出一条表达式用于确定一个整数是奇数还是偶数
```cpp 
i % 2 == 0? "even" : "odd"
```


## Exercise 4.7
> 溢出是何含义？ 写出三条将导致溢出的表达式
```cpp
short svalue = 32767; ++svalue; // -32768
unsigned uivalue = 0; --uivalue;  // 4294967295
unsigned short usvalue = 65535; ++usvalue;  // 0
```


## Exercise 4.8
> 说明在逻辑与、逻辑或及相等性运算符中运算对象求值的顺序

- 逻辑与（&&）：当且仅当左侧运算对象为真时才对右侧运算对象求值
- 逻辑或（||）：当且仅当左侧运算对象为假时才对右侧运算对象求值
- 相等性（==）：左右对象的值相等时返回true，否则返回false


## Exercise 4.9
> 解释在下面的if语句中条件部分的判断过程
> ```cpp
> const char *cp = "Hello World";
> if(cp && *cp)
> ```

首先判断cp是否为真，cp是指向字符串的指针，不是空指针，所以是true，所以之后判断`*cp`是否为真，因为`*cp`为字符串，有具体的值，所以是true，所以，`true && true == true`


## Exercise 4.10
> 为whle循环写一个条件，使其从标准输入中读取整数，遇到42时停止。
> ```cpp
> int i = 0
> while(cin >> i && i != 42)
> ```


## Exercise 4.11
> 书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。
> ```cpp
> (a > b) && (b > c) && (c > d)
> ```


## Exercise 4.12
> 假设i、j和k是三个整数，说明表达式`i != j < k`的含义。

因为`<`的优先级高于`!=`， 所以首先判断`j < k`是否为真， 若为真， 则判断`i != 1`; 若为假， 则判断`i != 0`


## Exercise 4.13
> 在下述语句中，当赋值完成后i和d的值分别是多少？
> ```cpp
> int i; double d;
> (a) d = i = 3.5;  // => i == 3, d == 3.0
> (b) i = d = 3.5;  // => i == 3, d == 3.5
> ```


## Exercise 4.14
> 执行下述if语句后将发生什么情况？
> ```cpp
> if (42 = i)   // 编译器报错，42非左值，不能执行赋值操作
> if (i = 42)   // 将42赋值给i，因为42为true，所以if语句为true，但如果本意是比较`i == 42`，可能后续会出现bug
> ```


## Exercise 4.15
> 下面的赋值是非法的，为什么？应该如何修改？
> ```cpp
> double dval; int ival; int *pi;
> dval = ival = pi = 0;   // => dval = ival = 0; pi = 0;
> ```

因为无法从`int*`类型转换成`int`类型，所以会出错


## Exercise 4.16
> 尽管下面的语句合法，但他们实际执行的行为可能和预期并不一样，为什么？应如何修改？
> ```cpp
> (a) if(p = getPtr() != 0)  
>     // 因为'!='的优先级要高于'='，所以实际执行是 if(p = (getPtr() != 0)), 将比较结果赋值给了p  
>     // => if((p = getPtr()) != 0)  
> (b) if(i = 1024)  
>     // 虽然不会报错，但是原意应该是对比i和1024，但是现在是将1024赋值给i  
>     // => if(i == 1024)


## Exercise 4.17
> 说明前置递增运算符和后置递增运算符的区别。

- 前置递增运算符：首先将运算对象加1，然后将改变后的对象作为左值返回。 
- 后置递增运算符：将运算对象加1，将原始值的副本作为右值返回。


## Exercise 4.18
> 如果第132页那个输出vector对象元素的while循环使用前置递增运算符，将得到什么结果？

可能发生错误，解引用一个不存在的元素


## Exercise 4.19
> 假设ptr的类型是指向int的指针、vec的类型是vector<int>、ival的类型是int，说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？  
> ```cpp
> (a) ptr != 0 && `*ptr++  `
>     // 确定ptr非0， 然后解引用ptr，再把ptr向前移动一个单位  
> (b) ival++ && ival  
>     // 判断ival是不是真，然后将ival加1， 再判断ival是不是真  
> (c) vec[ival++] <= vec[ival]  
>     //表达式不正确，关系运算符两端的对象都用到了ival，左侧还改变了ival的值  
>     // => vec[ival] <= vec[ival+1]


## Exercise 4.20
> 假设iter的类型是vector<string>::iterator，说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？
> ```cpp
> (a) *iter++;  // 解引用iter，并将指针向前移动一个单位
> (b) (*iter)++;  // 不合法，*iter是个string类型，不能执行++操作
> (c) *iter.empty(); // 不合法，成员运算符优先级高
> (d) iter->empty(); // 判断iter指向的值是否为空
> (e) ++*iter;  // 不合法，右结合律，*iter是string对象，不能执行++操作
> (f) iter++->empty();  // 判断iter->empty()，再将指针向前移动一个单位
  
  
## [Exercise 4.21](ex4_21.cpp)
> 编写一段程序，使用条件运算符从vector<int>中找到哪些元素的值是奇数和，然后将这些奇数值翻倍。

































